use crate::support::*;
use anyhow::{Context, Result};
use assert_cmd::prelude::*;
use cargo_component::registry::LOCK_FILE_NAME;
use predicates::{prelude::PredicateBooleanExt, str::contains};
use std::fs;
use toml_edit::{value, Document, Item, Table};

mod support;

#[test]
fn help() {
    for arg in ["help build", "build -h", "build --help"] {
        cargo_component(arg)
            .assert()
            .stdout(contains(
                "Compile a WebAssembly component and all of its dependencies",
            ))
            .success();
    }
}

#[test]
fn it_builds_debug() -> Result<()> {
    let project = Project::new("foo")?;
    project
        .cargo_component("build")
        .assert()
        .stderr(contains("Finished dev [unoptimized + debuginfo] target(s)"))
        .success();

    validate_component(&project.debug_wasm("foo"))?;

    let path = project.root().join(LOCK_FILE_NAME);
    let contents = fs::read_to_string(&path)
        .with_context(|| format!("failed to read lock file `{path}`", path = path.display()))?;

    let contents = contents.replace("\r\n", "\n");

    assert_eq!(
        contents,
        "# This file is automatically generated by cargo-component.\n# It is not intended for manual editing.\nversion = 1\n",
        "unexpected lock file contents"
    );

    Ok(())
}

#[test]
fn it_builds_a_bin_project() -> Result<()> {
    let project = Project::new_bin("foo")?;
    project
        .cargo_component("build --release")
        .assert()
        .stderr(contains("Finished release [optimized] target(s)"))
        .success();

    validate_component(&project.release_wasm("foo"))?;

    Ok(())
}

#[test]
fn it_builds_a_workspace() -> Result<()> {
    let project = project()?
        .file(
            "Cargo.toml",
            r#"[workspace]
members = ["foo", "bar", "baz"]
"#,
        )?
        .file(
            "baz/Cargo.toml",
            r#"[package]
name = "baz"
version = "0.1.0"
edition = "2021"
    
[dependencies]
"#,
        )?
        .file("baz/src/lib.rs", "")?
        .build();

    project
        .cargo_component("new --lib foo")
        .assert()
        .stderr(contains("Created component `foo` package"))
        .success();

    project
        .cargo_component("new --lib bar")
        .assert()
        .stderr(contains("Created component `bar` package"))
        .success();

    project
        .cargo_component("build")
        .assert()
        .stderr(contains("Finished dev [unoptimized + debuginfo] target(s)"))
        .success();

    validate_component(&project.debug_wasm("foo"))?;
    validate_component(&project.debug_wasm("bar"))?;

    Ok(())
}

#[test]
fn it_supports_wit_keywords() -> Result<()> {
    let project = Project::new("interface")?;
    project
        .cargo_component("build --release")
        .assert()
        .stderr(contains("Finished release [optimized] target(s)"))
        .success();

    validate_component(&project.release_wasm("interface"))?;

    Ok(())
}

#[test]
fn it_adds_a_producers_field() -> Result<()> {
    let project = Project::new("foo")?;
    project
        .cargo_component("build --release")
        .assert()
        .stderr(contains("Finished release [optimized] target(s)"))
        .success();

    let path = project.release_wasm("foo");

    validate_component(&path)?;

    let wasm = fs::read(&path)
        .with_context(|| format!("failed to read wasm file `{path}`", path = path.display()))?;
    let section = wasm_metadata::Producers::from_wasm(&wasm)?.expect("missing producers section");

    assert_eq!(
        section
            .get("processed-by")
            .expect("missing processed-by field")
            .get(env!("CARGO_PKG_NAME"))
            .expect("missing cargo-component field"),
        option_env!("CARGO_VERSION_INFO").unwrap_or(env!("CARGO_PKG_VERSION"))
    );

    Ok(())
}

#[test]
fn it_builds_wasm32_unknown_unknown() -> Result<()> {
    let project = Project::new("foo")?;
    project
        .cargo_component("build --target wasm32-unknown-unknown")
        .assert()
        .stderr(contains("Finished dev [unoptimized + debuginfo] target(s)"))
        .success();

    validate_component(
        &project
            .build_dir()
            .join("wasm32-unknown-unknown")
            .join("debug")
            .join("foo.wasm"),
    )?;

    Ok(())
}

#[test]
fn it_regenerates_bindings_if_wit_changed() -> Result<()> {
    let project = Project::new("foo")?;

    let manifest_path = project.root().join("Cargo.toml");
    let manifest = fs::read_to_string(&manifest_path)?;
    let mut doc: Document = manifest.parse()?;
    doc["package"]["metadata"]["component"]["target"]["world"] = value("example");
    fs::write(manifest_path, doc.to_string())?;

    project
        .cargo_component("build")
        .assert()
        .stderr(contains("Finished dev [unoptimized + debuginfo] target(s)"))
        .success();

    validate_component(&project.debug_wasm("foo"))?;

    project
        .cargo_component("build")
        .assert()
        .stderr(contains("Generating bindings").not())
        .success();

    fs::write(project.root().join("wit/other.wit"), "world foo {}")?;

    project
        .cargo_component("build")
        .assert()
        .stderr(contains("Generating bindings"))
        .success();

    Ok(())
}

#[test]
fn it_builds_with_local_wit_deps() -> Result<()> {
    let project = Project::new("foo")?;

    let manifest_path = project.root().join("Cargo.toml");
    let manifest = fs::read_to_string(&manifest_path)?;
    let mut doc: Document = manifest.parse()?;
    doc["package"]["metadata"]["component"]["target"]["path"] = value("wit");

    let mut dependencies = Table::new();
    dependencies["foo:bar"]["path"] = value("wit/deps/foo-bar");
    dependencies["bar:baz"]["path"] = value("wit/deps/bar-baz/qux.wit");
    dependencies["baz:qux"]["path"] = value("wit/deps/foo-bar/deps/baz-qux/qux.wit");

    doc["package"]["metadata"]["component"]["target"]["dependencies"] = Item::Table(dependencies);
    fs::write(manifest_path, doc.to_string())?;

    // Create the foo-bar wit package
    fs::create_dir_all(project.root().join("wit/deps/foo-bar/deps/baz-qux"))?;
    fs::write(
        project.root().join("wit/deps/foo-bar/deps/baz-qux/qux.wit"),
        "package baz:qux

interface qux {
    type ty = u32
}",
    )?;

    fs::write(
        project.root().join("wit/deps/foo-bar/bar.wit"),
        "package foo:bar

interface baz {
    use baz:qux/qux.{ty}
    baz: func() -> ty
}",
    )?;

    fs::create_dir_all(project.root().join("wit/deps/bar-baz"))?;

    fs::write(
        project.root().join("wit/deps/bar-baz/qux.wit"),
        "package bar:baz
interface qux {
    use baz:qux/qux.{ty}
    qux: func()
}",
    )?;

    fs::write(
        project.root().join("wit/world.wit"),
        "package component:foo

world example {
    export foo:bar/baz
    export bar:baz/qux
}",
    )?;

    fs::write(
        project.root().join("src/lib.rs"),
        "use bindings::exports::{foo::bar::baz::{Baz, Ty}, bar::baz::qux::Qux};
struct Component;

impl Baz for Component {
    fn baz() -> Ty {
        todo!()
    }
}

impl Qux for Component {
    fn qux() {
        todo!()
    }
}

bindings::export!(Component);",
    )?;

    project
        .cargo_component("build")
        .assert()
        .stderr(contains("Finished dev [unoptimized + debuginfo] target(s)"))
        .success();

    validate_component(&project.debug_wasm("foo"))?;

    Ok(())
}
