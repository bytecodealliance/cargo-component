use crate::support::*;
use anyhow::{Context, Result};
use assert_cmd::prelude::*;
use cargo_component::registry::LOCK_FILE_NAME;
use predicates::str::contains;
use std::fs;

mod support;

#[test]
fn help() {
    for arg in ["help build", "build -h", "build --help"] {
        cargo_component(arg)
            .assert()
            .stdout(contains(
                "Compile a WebAssembly component and all of its dependencies",
            ))
            .success();
    }
}

#[test]
fn it_builds_debug() -> Result<()> {
    let project = Project::new("foo")?;
    project
        .cargo_component("build")
        .assert()
        .stderr(contains("Finished dev [unoptimized + debuginfo] target(s)"))
        .success();

    validate_component(&project.debug_wasm("foo"))?;

    let path = project.root().join(LOCK_FILE_NAME);
    let contents = fs::read_to_string(&path)
        .with_context(|| format!("failed to read lock file `{path}`", path = path.display()))?;

    let contents = contents.replace("\r\n", "\n");

    assert_eq!(
        contents,
        "# This file is automatically generated by cargo-component.\n# It is not intended for manual editing.\nversion = 1\n",
        "unexpected lock file contents"
    );

    Ok(())
}

#[test]
fn it_builds_a_bin_project() -> Result<()> {
    let project = Project::new_bin("foo")?;
    project
        .cargo_component("build --release")
        .assert()
        .stderr(contains("Finished release [optimized] target(s)"))
        .success();

    validate_component(&project.release_wasm("foo"))?;

    Ok(())
}

#[test]
fn it_builds_a_workspace() -> Result<()> {
    let project = project()?
        .file(
            "Cargo.toml",
            r#"[workspace]
members = ["foo", "bar", "baz"]
"#,
        )?
        .file(
            "baz/Cargo.toml",
            r#"[package]
name = "baz"
version = "0.1.0"
edition = "2021"
    
[dependencies]
"#,
        )?
        .file("baz/src/lib.rs", "")?
        .build();

    project
        .cargo_component("new --lib foo")
        .assert()
        .stderr(contains("Created component `foo` package"))
        .success();

    project
        .cargo_component("new --lib bar")
        .assert()
        .stderr(contains("Created component `bar` package"))
        .success();

    project
        .cargo_component("build")
        .assert()
        .stderr(contains("Finished dev [unoptimized + debuginfo] target(s)"))
        .success();

    validate_component(&project.debug_wasm("foo"))?;
    validate_component(&project.debug_wasm("bar"))?;

    Ok(())
}

#[test]
fn it_supports_wit_keywords() -> Result<()> {
    let project = Project::new("interface")?;
    project
        .cargo_component("build --release")
        .assert()
        .stderr(contains("Finished release [optimized] target(s)"))
        .success();

    validate_component(&project.release_wasm("interface"))?;

    Ok(())
}

#[test]
fn it_adds_a_producers_field() -> Result<()> {
    let project = Project::new("foo")?;
    project
        .cargo_component("build --release")
        .assert()
        .stderr(contains("Finished release [optimized] target(s)"))
        .success();

    let path = project.release_wasm("foo");

    validate_component(&path)?;

    let wasm = fs::read(&path)
        .with_context(|| format!("failed to read wasm file `{path}`", path = path.display()))?;
    let section = wasm_metadata::Producers::from_wasm(&wasm)?.expect("missing producers section");

    assert_eq!(
        section
            .get("processed-by")
            .expect("missing processed-by field")
            .get(env!("CARGO_PKG_NAME"))
            .expect("missing cargo-component field"),
        option_env!("CARGO_VERSION_INFO").unwrap_or(env!("CARGO_PKG_VERSION"))
    );

    Ok(())
}

#[test]
fn it_builds_wasm32_unknown_unknown() -> Result<()> {
    let project = Project::new("foo")?;
    project
        .cargo_component("build --target wasm32-unknown-unknown")
        .assert()
        .stderr(contains("Finished dev [unoptimized + debuginfo] target(s)"))
        .success();

    validate_component(
        &project
            .build_dir()
            .join("wasm32-unknown-unknown")
            .join("debug")
            .join("foo.wasm"),
    )?;

    Ok(())
}
